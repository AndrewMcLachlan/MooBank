// This file is auto-generated by @hey-api/openapi-ts

import { type DefaultError, type InfiniteData, infiniteQueryOptions, queryOptions, type UseMutationOptions } from '@tanstack/react-query';
import type { AxiosError } from 'axios';

import { client } from '../client.gen';
import { addSubTag, addTag, addTagToInstrumentRule, allTagAverageReport, byTagReport, createAccount, createAsset, createBill, createBudgetLine, createFamily, createGroup, createInstitution, createInstrumentRule, createRecurringTransaction, createStockHolding, createStockTransaction, createTag, createTagByName, createTransaction, createVirtualInstrument, deleteBudgetLine, deleteGroup, deleteInstrumentRule, deleteRecurringTransaction, deleteTag, deleteVirtualInstrument, getAccount, getAccounts, getAllBills, getAllBudgetYears, getAllFamilies, getAllGroups, getAllInstitutions, getAllInstrumentRules, getAllRecurringTransactions, getAsset, getBill, getBillAccount, getBillAccounts, getBillAccountsByType, getBillAccountSummariesByType, getBillsForAnAccount, getBudget, getBudgetAmountForTag, getBudgetLine, getBudgetReport, getBudgetReportBreakdownForMonth, getBudgetReportBreakdownForMonthForUnbudgetedItems, getBudgetReportForMonth, getFamily, getFormattedInstrumentsList, getGroup, getInstitution, getInstrumentRule, getInstrumentsList, getRecurringTransaction, getRecurringTransactionsForAVirtualAccount, getStockHolding, getStockHoldingCpiAdjustedGainLoss, getStockTransactions, getTag, getTagHierarchy, getTags, getTransactions, getUntaggedTransactions, getUser, getVirtualInstrument, getVirtualInstruments, import_, importerTypes, inOutAverageReport, inOutReport, inOutTrendReport, monthlyBalancesReport, type Options, removeSubTag, removeTag, removeTagFromInstrumentRule, reprocess, runRules, searchTransactions, setBalance, stockHoldingReport, stockValueReport, tagBreakdownReport, tagTrendReport, updateAccount, updateAsset, updateBudgetLine, updateFamily, updateGroup, updateInstitution, updateInstrumentRule, updateRecurringTransaction, updateStockHolding, updateTag, updateTransaction, updateUser, updateVirtualInstrument } from '../sdk.gen';
import type { AddSubTagData, AddSubTagResponse, AddTagData, AddTagResponse, AddTagToInstrumentRuleData, AddTagToInstrumentRuleResponse, AllTagAverageReportData, AllTagAverageReportResponse, ByTagReportData, ByTagReportResponse, CreateAccountData, CreateAccountResponse, CreateAssetData, CreateAssetResponse, CreateBillData, CreateBillResponse, CreateBudgetLineData, CreateBudgetLineResponse, CreateFamilyData, CreateFamilyResponse, CreateGroupData, CreateGroupResponse, CreateInstitutionData, CreateInstitutionResponse, CreateInstrumentRuleData, CreateInstrumentRuleResponse, CreateRecurringTransactionData, CreateRecurringTransactionResponse, CreateStockHoldingData, CreateStockHoldingResponse, CreateStockTransactionData, CreateStockTransactionResponse, CreateTagByNameData, CreateTagByNameResponse, CreateTagData, CreateTagResponse, CreateTransactionData, CreateTransactionResponse, CreateVirtualInstrumentData, CreateVirtualInstrumentResponse, DeleteBudgetLineData, DeleteBudgetLineResponse, DeleteGroupData, DeleteGroupResponse, DeleteInstrumentRuleData, DeleteInstrumentRuleResponse, DeleteRecurringTransactionData, DeleteRecurringTransactionResponse, DeleteTagData, DeleteTagResponse, DeleteVirtualInstrumentData, DeleteVirtualInstrumentResponse, GetAccountData, GetAccountsData, GetAllBillsData, GetAllBudgetYearsData, GetAllFamiliesData, GetAllGroupsData, GetAllInstitutionsData, GetAllInstrumentRulesData, GetAllRecurringTransactionsData, GetAssetData, GetBillAccountData, GetBillAccountsByTypeData, GetBillAccountsData, GetBillAccountSummariesByTypeData, GetBillData, GetBillsForAnAccountData, GetBudgetAmountForTagData, GetBudgetData, GetBudgetLineData, GetBudgetReportBreakdownForMonthData, GetBudgetReportBreakdownForMonthForUnbudgetedItemsData, GetBudgetReportData, GetBudgetReportForMonthData, GetFamilyData, GetFormattedInstrumentsListData, GetGroupData, GetInstitutionData, GetInstrumentRuleData, GetInstrumentsListData, GetRecurringTransactionData, GetRecurringTransactionsForAVirtualAccountData, GetStockHoldingCpiAdjustedGainLossData, GetStockHoldingData, GetStockTransactionsData, GetTagData, GetTagHierarchyData, GetTagsData, GetTransactionsData, GetUntaggedTransactionsData, GetUserData, GetVirtualInstrumentData, GetVirtualInstrumentsData, ImportData, ImporterTypesData, InOutAverageReportData, InOutAverageReportResponse, InOutReportData, InOutReportResponse, InOutTrendReportData, InOutTrendReportResponse, MonthlyBalancesReportData, MonthlyBalancesReportResponse, RemoveSubTagData, RemoveSubTagResponse, RemoveTagData, RemoveTagFromInstrumentRuleData, RemoveTagFromInstrumentRuleResponse, RemoveTagResponse, ReprocessData, ReprocessResponse, RunRulesData, SearchTransactionsData, SetBalanceData, SetBalanceResponse, StockHoldingReportData, StockValueReportData, TagBreakdownReportData, TagBreakdownReportResponse, TagTrendReportData, TagTrendReportResponse, UpdateAccountData, UpdateAccountResponse, UpdateAssetData, UpdateAssetResponse, UpdateBudgetLineData, UpdateBudgetLineResponse, UpdateFamilyData, UpdateFamilyResponse, UpdateGroupData, UpdateGroupResponse, UpdateInstitutionData, UpdateInstitutionResponse, UpdateInstrumentRuleData, UpdateInstrumentRuleResponse, UpdateRecurringTransactionData, UpdateRecurringTransactionResponse, UpdateStockHoldingData, UpdateStockHoldingResponse, UpdateTagData, UpdateTagResponse, UpdateTransactionData, UpdateTransactionResponse, UpdateUserData, UpdateUserResponse, UpdateVirtualInstrumentData, UpdateVirtualInstrumentResponse } from '../types.gen';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseURL' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
        tags?: ReadonlyArray<string>;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean, tags?: ReadonlyArray<string>): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseURL: options?.baseURL || (options?.client ?? client).getConfig().baseURL } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (tags) {
        params.tags = tags;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [
        params
    ];
};

export const getAccountsQueryKey = (options?: Options<GetAccountsData>) => createQueryKey('getAccounts', options);

export const getAccountsOptions = (options?: Options<GetAccountsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAccounts({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAccountsQueryKey(options)
    });
};

export const createAccountMutation = (options?: Partial<Options<CreateAccountData>>): UseMutationOptions<CreateAccountResponse, AxiosError<DefaultError>, Options<CreateAccountData>> => {
    const mutationOptions: UseMutationOptions<CreateAccountResponse, AxiosError<DefaultError>, Options<CreateAccountData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createAccount({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAccountQueryKey = (options: Options<GetAccountData>) => createQueryKey('getAccount', options);

export const getAccountOptions = (options: Options<GetAccountData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAccount({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAccountQueryKey(options)
    });
};

export const updateAccountMutation = (options?: Partial<Options<UpdateAccountData>>): UseMutationOptions<UpdateAccountResponse, AxiosError<DefaultError>, Options<UpdateAccountData>> => {
    const mutationOptions: UseMutationOptions<UpdateAccountResponse, AxiosError<DefaultError>, Options<UpdateAccountData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateAccount({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAllRecurringTransactionsQueryKey = (options: Options<GetAllRecurringTransactionsData>) => createQueryKey('getAllRecurringTransactions', options);

export const getAllRecurringTransactionsOptions = (options: Options<GetAllRecurringTransactionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAllRecurringTransactions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllRecurringTransactionsQueryKey(options)
    });
};

export const createRecurringTransactionMutation = (options?: Partial<Options<CreateRecurringTransactionData>>): UseMutationOptions<CreateRecurringTransactionResponse, AxiosError<DefaultError>, Options<CreateRecurringTransactionData>> => {
    const mutationOptions: UseMutationOptions<CreateRecurringTransactionResponse, AxiosError<DefaultError>, Options<CreateRecurringTransactionData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createRecurringTransaction({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteRecurringTransactionMutation = (options?: Partial<Options<DeleteRecurringTransactionData>>): UseMutationOptions<DeleteRecurringTransactionResponse, AxiosError<DefaultError>, Options<DeleteRecurringTransactionData>> => {
    const mutationOptions: UseMutationOptions<DeleteRecurringTransactionResponse, AxiosError<DefaultError>, Options<DeleteRecurringTransactionData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteRecurringTransaction({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getRecurringTransactionQueryKey = (options: Options<GetRecurringTransactionData>) => createQueryKey('getRecurringTransaction', options);

export const getRecurringTransactionOptions = (options: Options<GetRecurringTransactionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getRecurringTransaction({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getRecurringTransactionQueryKey(options)
    });
};

export const updateRecurringTransactionMutation = (options?: Partial<Options<UpdateRecurringTransactionData>>): UseMutationOptions<UpdateRecurringTransactionResponse, AxiosError<DefaultError>, Options<UpdateRecurringTransactionData>> => {
    const mutationOptions: UseMutationOptions<UpdateRecurringTransactionResponse, AxiosError<DefaultError>, Options<UpdateRecurringTransactionData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateRecurringTransaction({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getRecurringTransactionsForAVirtualAccountQueryKey = (options: Options<GetRecurringTransactionsForAVirtualAccountData>) => createQueryKey('getRecurringTransactionsForAVirtualAccount', options);

export const getRecurringTransactionsForAVirtualAccountOptions = (options: Options<GetRecurringTransactionsForAVirtualAccountData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getRecurringTransactionsForAVirtualAccount({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getRecurringTransactionsForAVirtualAccountQueryKey(options)
    });
};

export const getAssetQueryKey = (options: Options<GetAssetData>) => createQueryKey('getAsset', options);

export const getAssetOptions = (options: Options<GetAssetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAsset({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAssetQueryKey(options)
    });
};

export const updateAssetMutation = (options?: Partial<Options<UpdateAssetData>>): UseMutationOptions<UpdateAssetResponse, AxiosError<DefaultError>, Options<UpdateAssetData>> => {
    const mutationOptions: UseMutationOptions<UpdateAssetResponse, AxiosError<DefaultError>, Options<UpdateAssetData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateAsset({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const createAssetMutation = (options?: Partial<Options<CreateAssetData>>): UseMutationOptions<CreateAssetResponse, AxiosError<DefaultError>, Options<CreateAssetData>> => {
    const mutationOptions: UseMutationOptions<CreateAssetResponse, AxiosError<DefaultError>, Options<CreateAssetData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createAsset({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAllBillsQueryKey = (options: Options<GetAllBillsData>) => createQueryKey('getAllBills', options);

export const getAllBillsOptions = (options: Options<GetAllBillsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAllBills({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllBillsQueryKey(options)
    });
};

export const getBillAccountSummariesByTypeQueryKey = (options?: Options<GetBillAccountSummariesByTypeData>) => createQueryKey('getBillAccountSummariesByType', options);

export const getBillAccountSummariesByTypeOptions = (options?: Options<GetBillAccountSummariesByTypeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getBillAccountSummariesByType({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getBillAccountSummariesByTypeQueryKey(options)
    });
};

export const getBillAccountsByTypeQueryKey = (options: Options<GetBillAccountsByTypeData>) => createQueryKey('getBillAccountsByType', options);

export const getBillAccountsByTypeOptions = (options: Options<GetBillAccountsByTypeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getBillAccountsByType({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getBillAccountsByTypeQueryKey(options)
    });
};

export const getBillAccountsQueryKey = (options?: Options<GetBillAccountsData>) => createQueryKey('getBillAccounts', options);

export const getBillAccountsOptions = (options?: Options<GetBillAccountsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getBillAccounts({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getBillAccountsQueryKey(options)
    });
};

export const getBillAccountQueryKey = (options: Options<GetBillAccountData>) => createQueryKey('getBillAccount', options);

export const getBillAccountOptions = (options: Options<GetBillAccountData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getBillAccount({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getBillAccountQueryKey(options)
    });
};

export const getBillsForAnAccountQueryKey = (options: Options<GetBillsForAnAccountData>) => createQueryKey('getBillsForAnAccount', options);

export const getBillsForAnAccountOptions = (options: Options<GetBillsForAnAccountData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getBillsForAnAccount({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getBillsForAnAccountQueryKey(options)
    });
};

export const createBillMutation = (options?: Partial<Options<CreateBillData>>): UseMutationOptions<CreateBillResponse, AxiosError<DefaultError>, Options<CreateBillData>> => {
    const mutationOptions: UseMutationOptions<CreateBillResponse, AxiosError<DefaultError>, Options<CreateBillData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createBill({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getBillQueryKey = (options: Options<GetBillData>) => createQueryKey('getBill', options);

export const getBillOptions = (options: Options<GetBillData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getBill({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getBillQueryKey(options)
    });
};

export const getAllBudgetYearsQueryKey = (options?: Options<GetAllBudgetYearsData>) => createQueryKey('getAllBudgetYears', options);

export const getAllBudgetYearsOptions = (options?: Options<GetAllBudgetYearsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAllBudgetYears({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllBudgetYearsQueryKey(options)
    });
};

export const getBudgetQueryKey = (options: Options<GetBudgetData>) => createQueryKey('getBudget', options);

export const getBudgetOptions = (options: Options<GetBudgetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getBudget({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getBudgetQueryKey(options)
    });
};

export const deleteBudgetLineMutation = (options?: Partial<Options<DeleteBudgetLineData>>): UseMutationOptions<DeleteBudgetLineResponse, AxiosError<DefaultError>, Options<DeleteBudgetLineData>> => {
    const mutationOptions: UseMutationOptions<DeleteBudgetLineResponse, AxiosError<DefaultError>, Options<DeleteBudgetLineData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteBudgetLine({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getBudgetLineQueryKey = (options: Options<GetBudgetLineData>) => createQueryKey('getBudgetLine', options);

export const getBudgetLineOptions = (options: Options<GetBudgetLineData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getBudgetLine({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getBudgetLineQueryKey(options)
    });
};

export const updateBudgetLineMutation = (options?: Partial<Options<UpdateBudgetLineData>>): UseMutationOptions<UpdateBudgetLineResponse, AxiosError<DefaultError>, Options<UpdateBudgetLineData>> => {
    const mutationOptions: UseMutationOptions<UpdateBudgetLineResponse, AxiosError<DefaultError>, Options<UpdateBudgetLineData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateBudgetLine({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const createBudgetLineMutation = (options?: Partial<Options<CreateBudgetLineData>>): UseMutationOptions<CreateBudgetLineResponse, AxiosError<DefaultError>, Options<CreateBudgetLineData>> => {
    const mutationOptions: UseMutationOptions<CreateBudgetLineResponse, AxiosError<DefaultError>, Options<CreateBudgetLineData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createBudgetLine({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getBudgetAmountForTagQueryKey = (options: Options<GetBudgetAmountForTagData>) => createQueryKey('getBudgetAmountForTag', options);

export const getBudgetAmountForTagOptions = (options: Options<GetBudgetAmountForTagData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getBudgetAmountForTag({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getBudgetAmountForTagQueryKey(options)
    });
};

export const getBudgetReportQueryKey = (options: Options<GetBudgetReportData>) => createQueryKey('getBudgetReport', options);

export const getBudgetReportOptions = (options: Options<GetBudgetReportData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getBudgetReport({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getBudgetReportQueryKey(options)
    });
};

export const getBudgetReportForMonthQueryKey = (options: Options<GetBudgetReportForMonthData>) => createQueryKey('getBudgetReportForMonth', options);

export const getBudgetReportForMonthOptions = (options: Options<GetBudgetReportForMonthData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getBudgetReportForMonth({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getBudgetReportForMonthQueryKey(options)
    });
};

export const getBudgetReportBreakdownForMonthQueryKey = (options: Options<GetBudgetReportBreakdownForMonthData>) => createQueryKey('getBudgetReportBreakdownForMonth', options);

export const getBudgetReportBreakdownForMonthOptions = (options: Options<GetBudgetReportBreakdownForMonthData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getBudgetReportBreakdownForMonth({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getBudgetReportBreakdownForMonthQueryKey(options)
    });
};

export const getBudgetReportBreakdownForMonthForUnbudgetedItemsQueryKey = (options: Options<GetBudgetReportBreakdownForMonthForUnbudgetedItemsData>) => createQueryKey('getBudgetReportBreakdownForMonthForUnbudgetedItems', options);

export const getBudgetReportBreakdownForMonthForUnbudgetedItemsOptions = (options: Options<GetBudgetReportBreakdownForMonthForUnbudgetedItemsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getBudgetReportBreakdownForMonthForUnbudgetedItems({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getBudgetReportBreakdownForMonthForUnbudgetedItemsQueryKey(options)
    });
};

export const getAllFamiliesQueryKey = (options?: Options<GetAllFamiliesData>) => createQueryKey('getAllFamilies', options);

export const getAllFamiliesOptions = (options?: Options<GetAllFamiliesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAllFamilies({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllFamiliesQueryKey(options)
    });
};

export const createFamilyMutation = (options?: Partial<Options<CreateFamilyData>>): UseMutationOptions<CreateFamilyResponse, AxiosError<DefaultError>, Options<CreateFamilyData>> => {
    const mutationOptions: UseMutationOptions<CreateFamilyResponse, AxiosError<DefaultError>, Options<CreateFamilyData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createFamily({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getFamilyQueryKey = (options: Options<GetFamilyData>) => createQueryKey('getFamily', options);

export const getFamilyOptions = (options: Options<GetFamilyData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getFamily({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getFamilyQueryKey(options)
    });
};

export const updateFamilyMutation = (options?: Partial<Options<UpdateFamilyData>>): UseMutationOptions<UpdateFamilyResponse, AxiosError<DefaultError>, Options<UpdateFamilyData>> => {
    const mutationOptions: UseMutationOptions<UpdateFamilyResponse, AxiosError<DefaultError>, Options<UpdateFamilyData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateFamily({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAllGroupsQueryKey = (options?: Options<GetAllGroupsData>) => createQueryKey('getAllGroups', options);

export const getAllGroupsOptions = (options?: Options<GetAllGroupsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAllGroups({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllGroupsQueryKey(options)
    });
};

export const createGroupMutation = (options?: Partial<Options<CreateGroupData>>): UseMutationOptions<CreateGroupResponse, AxiosError<DefaultError>, Options<CreateGroupData>> => {
    const mutationOptions: UseMutationOptions<CreateGroupResponse, AxiosError<DefaultError>, Options<CreateGroupData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createGroup({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteGroupMutation = (options?: Partial<Options<DeleteGroupData>>): UseMutationOptions<DeleteGroupResponse, AxiosError<DefaultError>, Options<DeleteGroupData>> => {
    const mutationOptions: UseMutationOptions<DeleteGroupResponse, AxiosError<DefaultError>, Options<DeleteGroupData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteGroup({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getGroupQueryKey = (options: Options<GetGroupData>) => createQueryKey('getGroup', options);

export const getGroupOptions = (options: Options<GetGroupData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getGroup({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getGroupQueryKey(options)
    });
};

export const updateGroupMutation = (options?: Partial<Options<UpdateGroupData>>): UseMutationOptions<UpdateGroupResponse, AxiosError<DefaultError>, Options<UpdateGroupData>> => {
    const mutationOptions: UseMutationOptions<UpdateGroupResponse, AxiosError<DefaultError>, Options<UpdateGroupData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateGroup({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAllInstitutionsQueryKey = (options?: Options<GetAllInstitutionsData>) => createQueryKey('getAllInstitutions', options);

export const getAllInstitutionsOptions = (options?: Options<GetAllInstitutionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAllInstitutions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllInstitutionsQueryKey(options)
    });
};

export const createInstitutionMutation = (options?: Partial<Options<CreateInstitutionData>>): UseMutationOptions<CreateInstitutionResponse, AxiosError<DefaultError>, Options<CreateInstitutionData>> => {
    const mutationOptions: UseMutationOptions<CreateInstitutionResponse, AxiosError<DefaultError>, Options<CreateInstitutionData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createInstitution({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getInstitutionQueryKey = (options: Options<GetInstitutionData>) => createQueryKey('getInstitution', options);

export const getInstitutionOptions = (options: Options<GetInstitutionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getInstitution({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getInstitutionQueryKey(options)
    });
};

export const updateInstitutionMutation = (options?: Partial<Options<UpdateInstitutionData>>): UseMutationOptions<UpdateInstitutionResponse, AxiosError<DefaultError>, Options<UpdateInstitutionData>> => {
    const mutationOptions: UseMutationOptions<UpdateInstitutionResponse, AxiosError<DefaultError>, Options<UpdateInstitutionData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateInstitution({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getFormattedInstrumentsListQueryKey = (options?: Options<GetFormattedInstrumentsListData>) => createQueryKey('getFormattedInstrumentsList', options);

export const getFormattedInstrumentsListOptions = (options?: Options<GetFormattedInstrumentsListData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getFormattedInstrumentsList({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getFormattedInstrumentsListQueryKey(options)
    });
};

export const getInstrumentsListQueryKey = (options?: Options<GetInstrumentsListData>) => createQueryKey('getInstrumentsList', options);

export const getInstrumentsListOptions = (options?: Options<GetInstrumentsListData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getInstrumentsList({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getInstrumentsListQueryKey(options)
    });
};

export const importMutation = (options?: Partial<Options<ImportData>>): UseMutationOptions<unknown, AxiosError<DefaultError>, Options<ImportData>> => {
    const mutationOptions: UseMutationOptions<unknown, AxiosError<DefaultError>, Options<ImportData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await import_({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const reprocessMutation = (options?: Partial<Options<ReprocessData>>): UseMutationOptions<ReprocessResponse, AxiosError<DefaultError>, Options<ReprocessData>> => {
    const mutationOptions: UseMutationOptions<ReprocessResponse, AxiosError<DefaultError>, Options<ReprocessData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await reprocess({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAllInstrumentRulesQueryKey = (options: Options<GetAllInstrumentRulesData>) => createQueryKey('getAllInstrumentRules', options);

export const getAllInstrumentRulesOptions = (options: Options<GetAllInstrumentRulesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAllInstrumentRules({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllInstrumentRulesQueryKey(options)
    });
};

export const createInstrumentRuleMutation = (options?: Partial<Options<CreateInstrumentRuleData>>): UseMutationOptions<CreateInstrumentRuleResponse, AxiosError<DefaultError>, Options<CreateInstrumentRuleData>> => {
    const mutationOptions: UseMutationOptions<CreateInstrumentRuleResponse, AxiosError<DefaultError>, Options<CreateInstrumentRuleData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createInstrumentRule({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteInstrumentRuleMutation = (options?: Partial<Options<DeleteInstrumentRuleData>>): UseMutationOptions<DeleteInstrumentRuleResponse, AxiosError<DefaultError>, Options<DeleteInstrumentRuleData>> => {
    const mutationOptions: UseMutationOptions<DeleteInstrumentRuleResponse, AxiosError<DefaultError>, Options<DeleteInstrumentRuleData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteInstrumentRule({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getInstrumentRuleQueryKey = (options: Options<GetInstrumentRuleData>) => createQueryKey('getInstrumentRule', options);

export const getInstrumentRuleOptions = (options: Options<GetInstrumentRuleData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getInstrumentRule({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getInstrumentRuleQueryKey(options)
    });
};

export const updateInstrumentRuleMutation = (options?: Partial<Options<UpdateInstrumentRuleData>>): UseMutationOptions<UpdateInstrumentRuleResponse, AxiosError<DefaultError>, Options<UpdateInstrumentRuleData>> => {
    const mutationOptions: UseMutationOptions<UpdateInstrumentRuleResponse, AxiosError<DefaultError>, Options<UpdateInstrumentRuleData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateInstrumentRule({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const removeTagFromInstrumentRuleMutation = (options?: Partial<Options<RemoveTagFromInstrumentRuleData>>): UseMutationOptions<RemoveTagFromInstrumentRuleResponse, AxiosError<DefaultError>, Options<RemoveTagFromInstrumentRuleData>> => {
    const mutationOptions: UseMutationOptions<RemoveTagFromInstrumentRuleResponse, AxiosError<DefaultError>, Options<RemoveTagFromInstrumentRuleData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await removeTagFromInstrumentRule({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const addTagToInstrumentRuleMutation = (options?: Partial<Options<AddTagToInstrumentRuleData>>): UseMutationOptions<AddTagToInstrumentRuleResponse, AxiosError<DefaultError>, Options<AddTagToInstrumentRuleData>> => {
    const mutationOptions: UseMutationOptions<AddTagToInstrumentRuleResponse, AxiosError<DefaultError>, Options<AddTagToInstrumentRuleData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await addTagToInstrumentRule({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const runRulesMutation = (options?: Partial<Options<RunRulesData>>): UseMutationOptions<unknown, AxiosError<DefaultError>, Options<RunRulesData>> => {
    const mutationOptions: UseMutationOptions<unknown, AxiosError<DefaultError>, Options<RunRulesData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await runRules({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getVirtualInstrumentsQueryKey = (options: Options<GetVirtualInstrumentsData>) => createQueryKey('getVirtualInstruments', options);

export const getVirtualInstrumentsOptions = (options: Options<GetVirtualInstrumentsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getVirtualInstruments({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getVirtualInstrumentsQueryKey(options)
    });
};

export const createVirtualInstrumentMutation = (options?: Partial<Options<CreateVirtualInstrumentData>>): UseMutationOptions<CreateVirtualInstrumentResponse, AxiosError<DefaultError>, Options<CreateVirtualInstrumentData>> => {
    const mutationOptions: UseMutationOptions<CreateVirtualInstrumentResponse, AxiosError<DefaultError>, Options<CreateVirtualInstrumentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createVirtualInstrument({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteVirtualInstrumentMutation = (options?: Partial<Options<DeleteVirtualInstrumentData>>): UseMutationOptions<DeleteVirtualInstrumentResponse, AxiosError<DefaultError>, Options<DeleteVirtualInstrumentData>> => {
    const mutationOptions: UseMutationOptions<DeleteVirtualInstrumentResponse, AxiosError<DefaultError>, Options<DeleteVirtualInstrumentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteVirtualInstrument({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getVirtualInstrumentQueryKey = (options: Options<GetVirtualInstrumentData>) => createQueryKey('getVirtualInstrument', options);

export const getVirtualInstrumentOptions = (options: Options<GetVirtualInstrumentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getVirtualInstrument({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getVirtualInstrumentQueryKey(options)
    });
};

export const updateVirtualInstrumentMutation = (options?: Partial<Options<UpdateVirtualInstrumentData>>): UseMutationOptions<UpdateVirtualInstrumentResponse, AxiosError<DefaultError>, Options<UpdateVirtualInstrumentData>> => {
    const mutationOptions: UseMutationOptions<UpdateVirtualInstrumentResponse, AxiosError<DefaultError>, Options<UpdateVirtualInstrumentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateVirtualInstrument({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const importerTypesQueryKey = (options?: Options<ImporterTypesData>) => createQueryKey('importerTypes', options);

export const importerTypesOptions = (options?: Options<ImporterTypesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await importerTypes({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: importerTypesQueryKey(options)
    });
};

export const inOutReportQueryKey = (options: Options<InOutReportData>) => createQueryKey('inOutReport', options);

export const inOutReportOptions = (options: Options<InOutReportData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await inOutReport({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: inOutReportQueryKey(options)
    });
};

const createInfiniteParams = <K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>>(queryKey: QueryKey<Options>, page: K) => {
    const params = {
        ...queryKey[0]
    };
    if (page.body) {
        params.body = {
            ...queryKey[0].body as any,
            ...page.body as any
        };
    }
    if (page.headers) {
        params.headers = {
            ...queryKey[0].headers,
            ...page.headers
        };
    }
    if (page.path) {
        params.path = {
            ...queryKey[0].path as any,
            ...page.path as any
        };
    }
    if (page.query) {
        params.query = {
            ...queryKey[0].query as any,
            ...page.query as any
        };
    }
    return params as unknown as typeof page;
};

export const inOutReportInfiniteQueryKey = (options: Options<InOutReportData>): QueryKey<Options<InOutReportData>> => createQueryKey('inOutReport', options, true);

export const inOutReportInfiniteOptions = (options: Options<InOutReportData>) => {
    return infiniteQueryOptions<InOutReportResponse, AxiosError<DefaultError>, InfiniteData<InOutReportResponse>, QueryKey<Options<InOutReportData>>, string | Pick<QueryKey<Options<InOutReportData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<InOutReportData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                path: {
                    start: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await inOutReport({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: inOutReportInfiniteQueryKey(options)
    });
};

export const inOutTrendReportQueryKey = (options: Options<InOutTrendReportData>) => createQueryKey('inOutTrendReport', options);

export const inOutTrendReportOptions = (options: Options<InOutTrendReportData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await inOutTrendReport({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: inOutTrendReportQueryKey(options)
    });
};

export const inOutTrendReportInfiniteQueryKey = (options: Options<InOutTrendReportData>): QueryKey<Options<InOutTrendReportData>> => createQueryKey('inOutTrendReport', options, true);

export const inOutTrendReportInfiniteOptions = (options: Options<InOutTrendReportData>) => {
    return infiniteQueryOptions<InOutTrendReportResponse, AxiosError<DefaultError>, InfiniteData<InOutTrendReportResponse>, QueryKey<Options<InOutTrendReportData>>, string | Pick<QueryKey<Options<InOutTrendReportData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<InOutTrendReportData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                path: {
                    start: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await inOutTrendReport({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: inOutTrendReportInfiniteQueryKey(options)
    });
};

export const inOutAverageReportQueryKey = (options: Options<InOutAverageReportData>) => createQueryKey('inOutAverageReport', options);

export const inOutAverageReportOptions = (options: Options<InOutAverageReportData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await inOutAverageReport({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: inOutAverageReportQueryKey(options)
    });
};

export const inOutAverageReportInfiniteQueryKey = (options: Options<InOutAverageReportData>): QueryKey<Options<InOutAverageReportData>> => createQueryKey('inOutAverageReport', options, true);

export const inOutAverageReportInfiniteOptions = (options: Options<InOutAverageReportData>) => {
    return infiniteQueryOptions<InOutAverageReportResponse, AxiosError<DefaultError>, InfiniteData<InOutAverageReportResponse>, QueryKey<Options<InOutAverageReportData>>, string | Pick<QueryKey<Options<InOutAverageReportData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<InOutAverageReportData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                path: {
                    start: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await inOutAverageReport({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: inOutAverageReportInfiniteQueryKey(options)
    });
};

export const byTagReportQueryKey = (options: Options<ByTagReportData>) => createQueryKey('byTagReport', options);

export const byTagReportOptions = (options: Options<ByTagReportData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await byTagReport({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: byTagReportQueryKey(options)
    });
};

export const byTagReportInfiniteQueryKey = (options: Options<ByTagReportData>): QueryKey<Options<ByTagReportData>> => createQueryKey('byTagReport', options, true);

export const byTagReportInfiniteOptions = (options: Options<ByTagReportData>) => {
    return infiniteQueryOptions<ByTagReportResponse, AxiosError<DefaultError>, InfiniteData<ByTagReportResponse>, QueryKey<Options<ByTagReportData>>, string | Pick<QueryKey<Options<ByTagReportData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ByTagReportData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                path: {
                    start: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await byTagReport({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: byTagReportInfiniteQueryKey(options)
    });
};

export const tagBreakdownReportQueryKey = (options: Options<TagBreakdownReportData>) => createQueryKey('tagBreakdownReport', options);

export const tagBreakdownReportOptions = (options: Options<TagBreakdownReportData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await tagBreakdownReport({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: tagBreakdownReportQueryKey(options)
    });
};

export const tagBreakdownReportInfiniteQueryKey = (options: Options<TagBreakdownReportData>): QueryKey<Options<TagBreakdownReportData>> => createQueryKey('tagBreakdownReport', options, true);

export const tagBreakdownReportInfiniteOptions = (options: Options<TagBreakdownReportData>) => {
    return infiniteQueryOptions<TagBreakdownReportResponse, AxiosError<DefaultError>, InfiniteData<TagBreakdownReportResponse>, QueryKey<Options<TagBreakdownReportData>>, string | Pick<QueryKey<Options<TagBreakdownReportData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<TagBreakdownReportData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                path: {
                    start: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await tagBreakdownReport({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: tagBreakdownReportInfiniteQueryKey(options)
    });
};

export const tagTrendReportQueryKey = (options: Options<TagTrendReportData>) => createQueryKey('tagTrendReport', options);

export const tagTrendReportOptions = (options: Options<TagTrendReportData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await tagTrendReport({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: tagTrendReportQueryKey(options)
    });
};

export const tagTrendReportInfiniteQueryKey = (options: Options<TagTrendReportData>): QueryKey<Options<TagTrendReportData>> => createQueryKey('tagTrendReport', options, true);

export const tagTrendReportInfiniteOptions = (options: Options<TagTrendReportData>) => {
    return infiniteQueryOptions<TagTrendReportResponse, AxiosError<DefaultError>, InfiniteData<TagTrendReportResponse>, QueryKey<Options<TagTrendReportData>>, string | Pick<QueryKey<Options<TagTrendReportData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<TagTrendReportData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                path: {
                    start: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await tagTrendReport({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: tagTrendReportInfiniteQueryKey(options)
    });
};

export const allTagAverageReportQueryKey = (options: Options<AllTagAverageReportData>) => createQueryKey('allTagAverageReport', options);

export const allTagAverageReportOptions = (options: Options<AllTagAverageReportData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await allTagAverageReport({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: allTagAverageReportQueryKey(options)
    });
};

export const allTagAverageReportInfiniteQueryKey = (options: Options<AllTagAverageReportData>): QueryKey<Options<AllTagAverageReportData>> => createQueryKey('allTagAverageReport', options, true);

export const allTagAverageReportInfiniteOptions = (options: Options<AllTagAverageReportData>) => {
    return infiniteQueryOptions<AllTagAverageReportResponse, AxiosError<DefaultError>, InfiniteData<AllTagAverageReportResponse>, QueryKey<Options<AllTagAverageReportData>>, string | Pick<QueryKey<Options<AllTagAverageReportData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<AllTagAverageReportData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                path: {
                    start: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await allTagAverageReport({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: allTagAverageReportInfiniteQueryKey(options)
    });
};

export const monthlyBalancesReportQueryKey = (options: Options<MonthlyBalancesReportData>) => createQueryKey('monthlyBalancesReport', options);

export const monthlyBalancesReportOptions = (options: Options<MonthlyBalancesReportData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await monthlyBalancesReport({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: monthlyBalancesReportQueryKey(options)
    });
};

export const monthlyBalancesReportInfiniteQueryKey = (options: Options<MonthlyBalancesReportData>): QueryKey<Options<MonthlyBalancesReportData>> => createQueryKey('monthlyBalancesReport', options, true);

export const monthlyBalancesReportInfiniteOptions = (options: Options<MonthlyBalancesReportData>) => {
    return infiniteQueryOptions<MonthlyBalancesReportResponse, AxiosError<DefaultError>, InfiniteData<MonthlyBalancesReportResponse>, QueryKey<Options<MonthlyBalancesReportData>>, string | Pick<QueryKey<Options<MonthlyBalancesReportData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<MonthlyBalancesReportData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                path: {
                    start: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await monthlyBalancesReport({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: monthlyBalancesReportInfiniteQueryKey(options)
    });
};

export const getStockHoldingQueryKey = (options: Options<GetStockHoldingData>) => createQueryKey('getStockHolding', options);

export const getStockHoldingOptions = (options: Options<GetStockHoldingData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getStockHolding({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getStockHoldingQueryKey(options)
    });
};

export const updateStockHoldingMutation = (options?: Partial<Options<UpdateStockHoldingData>>): UseMutationOptions<UpdateStockHoldingResponse, AxiosError<DefaultError>, Options<UpdateStockHoldingData>> => {
    const mutationOptions: UseMutationOptions<UpdateStockHoldingResponse, AxiosError<DefaultError>, Options<UpdateStockHoldingData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateStockHolding({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getStockHoldingCpiAdjustedGainLossQueryKey = (options: Options<GetStockHoldingCpiAdjustedGainLossData>) => createQueryKey('getStockHoldingCpiAdjustedGainLoss', options);

export const getStockHoldingCpiAdjustedGainLossOptions = (options: Options<GetStockHoldingCpiAdjustedGainLossData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getStockHoldingCpiAdjustedGainLoss({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getStockHoldingCpiAdjustedGainLossQueryKey(options)
    });
};

export const createStockHoldingMutation = (options?: Partial<Options<CreateStockHoldingData>>): UseMutationOptions<CreateStockHoldingResponse, AxiosError<DefaultError>, Options<CreateStockHoldingData>> => {
    const mutationOptions: UseMutationOptions<CreateStockHoldingResponse, AxiosError<DefaultError>, Options<CreateStockHoldingData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createStockHolding({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const stockHoldingReportQueryKey = (options: Options<StockHoldingReportData>) => createQueryKey('stockHoldingReport', options);

export const stockHoldingReportOptions = (options: Options<StockHoldingReportData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await stockHoldingReport({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: stockHoldingReportQueryKey(options)
    });
};

export const stockValueReportQueryKey = (options: Options<StockValueReportData>) => createQueryKey('stockValueReport', options);

export const stockValueReportOptions = (options: Options<StockValueReportData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await stockValueReport({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: stockValueReportQueryKey(options)
    });
};

export const getStockTransactionsQueryKey = (options: Options<GetStockTransactionsData>) => createQueryKey('getStockTransactions', options);

export const getStockTransactionsOptions = (options: Options<GetStockTransactionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getStockTransactions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getStockTransactionsQueryKey(options)
    });
};

export const createStockTransactionMutation = (options?: Partial<Options<CreateStockTransactionData>>): UseMutationOptions<CreateStockTransactionResponse, AxiosError<DefaultError>, Options<CreateStockTransactionData>> => {
    const mutationOptions: UseMutationOptions<CreateStockTransactionResponse, AxiosError<DefaultError>, Options<CreateStockTransactionData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createStockTransaction({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getTagsQueryKey = (options?: Options<GetTagsData>) => createQueryKey('getTags', options);

export const getTagsOptions = (options?: Options<GetTagsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTags({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTagsQueryKey(options)
    });
};

export const createTagMutation = (options?: Partial<Options<CreateTagData>>): UseMutationOptions<CreateTagResponse, AxiosError<DefaultError>, Options<CreateTagData>> => {
    const mutationOptions: UseMutationOptions<CreateTagResponse, AxiosError<DefaultError>, Options<CreateTagData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createTag({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getTagHierarchyQueryKey = (options?: Options<GetTagHierarchyData>) => createQueryKey('getTagHierarchy', options);

export const getTagHierarchyOptions = (options?: Options<GetTagHierarchyData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTagHierarchy({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTagHierarchyQueryKey(options)
    });
};

export const deleteTagMutation = (options?: Partial<Options<DeleteTagData>>): UseMutationOptions<DeleteTagResponse, AxiosError<DefaultError>, Options<DeleteTagData>> => {
    const mutationOptions: UseMutationOptions<DeleteTagResponse, AxiosError<DefaultError>, Options<DeleteTagData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteTag({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getTagQueryKey = (options: Options<GetTagData>) => createQueryKey('getTag', options);

export const getTagOptions = (options: Options<GetTagData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTag({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTagQueryKey(options)
    });
};

export const updateTagMutation = (options?: Partial<Options<UpdateTagData>>): UseMutationOptions<UpdateTagResponse, AxiosError<DefaultError>, Options<UpdateTagData>> => {
    const mutationOptions: UseMutationOptions<UpdateTagResponse, AxiosError<DefaultError>, Options<UpdateTagData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateTag({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Create a tag by name
 */
export const createTagByNameMutation = (options?: Partial<Options<CreateTagByNameData>>): UseMutationOptions<CreateTagByNameResponse, AxiosError<DefaultError>, Options<CreateTagByNameData>> => {
    const mutationOptions: UseMutationOptions<CreateTagByNameResponse, AxiosError<DefaultError>, Options<CreateTagByNameData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createTagByName({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const removeSubTagMutation = (options?: Partial<Options<RemoveSubTagData>>): UseMutationOptions<RemoveSubTagResponse, AxiosError<DefaultError>, Options<RemoveSubTagData>> => {
    const mutationOptions: UseMutationOptions<RemoveSubTagResponse, AxiosError<DefaultError>, Options<RemoveSubTagData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await removeSubTag({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const addSubTagMutation = (options?: Partial<Options<AddSubTagData>>): UseMutationOptions<AddSubTagResponse, AxiosError<DefaultError>, Options<AddSubTagData>> => {
    const mutationOptions: UseMutationOptions<AddSubTagResponse, AxiosError<DefaultError>, Options<AddSubTagData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await addSubTag({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getTransactionsQueryKey = (options: Options<GetTransactionsData>) => createQueryKey('getTransactions', options);

export const getTransactionsOptions = (options: Options<GetTransactionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTransactions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTransactionsQueryKey(options)
    });
};

export const getUntaggedTransactionsQueryKey = (options: Options<GetUntaggedTransactionsData>) => createQueryKey('getUntaggedTransactions', options);

export const getUntaggedTransactionsOptions = (options: Options<GetUntaggedTransactionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUntaggedTransactions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUntaggedTransactionsQueryKey(options)
    });
};

export const searchTransactionsQueryKey = (options: Options<SearchTransactionsData>) => createQueryKey('searchTransactions', options);

export const searchTransactionsOptions = (options: Options<SearchTransactionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await searchTransactions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: searchTransactionsQueryKey(options)
    });
};

export const createTransactionMutation = (options?: Partial<Options<CreateTransactionData>>): UseMutationOptions<CreateTransactionResponse, AxiosError<DefaultError>, Options<CreateTransactionData>> => {
    const mutationOptions: UseMutationOptions<CreateTransactionResponse, AxiosError<DefaultError>, Options<CreateTransactionData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createTransaction({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const setBalanceMutation = (options?: Partial<Options<SetBalanceData>>): UseMutationOptions<SetBalanceResponse, AxiosError<DefaultError>, Options<SetBalanceData>> => {
    const mutationOptions: UseMutationOptions<SetBalanceResponse, AxiosError<DefaultError>, Options<SetBalanceData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await setBalance({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const updateTransactionMutation = (options?: Partial<Options<UpdateTransactionData>>): UseMutationOptions<UpdateTransactionResponse, AxiosError<DefaultError>, Options<UpdateTransactionData>> => {
    const mutationOptions: UseMutationOptions<UpdateTransactionResponse, AxiosError<DefaultError>, Options<UpdateTransactionData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateTransaction({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const removeTagMutation = (options?: Partial<Options<RemoveTagData>>): UseMutationOptions<RemoveTagResponse, AxiosError<DefaultError>, Options<RemoveTagData>> => {
    const mutationOptions: UseMutationOptions<RemoveTagResponse, AxiosError<DefaultError>, Options<RemoveTagData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await removeTag({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const addTagMutation = (options?: Partial<Options<AddTagData>>): UseMutationOptions<AddTagResponse, AxiosError<DefaultError>, Options<AddTagData>> => {
    const mutationOptions: UseMutationOptions<AddTagResponse, AxiosError<DefaultError>, Options<AddTagData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await addTag({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getUserQueryKey = (options?: Options<GetUserData>) => createQueryKey('getUser', options);

export const getUserOptions = (options?: Options<GetUserData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUser({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUserQueryKey(options)
    });
};

export const updateUserMutation = (options?: Partial<Options<UpdateUserData>>): UseMutationOptions<UpdateUserResponse, AxiosError<DefaultError>, Options<UpdateUserData>> => {
    const mutationOptions: UseMutationOptions<UpdateUserResponse, AxiosError<DefaultError>, Options<UpdateUserData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateUser({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};
